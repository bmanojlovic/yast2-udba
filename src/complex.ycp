/**
 * File:	include/udba/complex.ycp
 * Package:	Universal Driver Build Assistant
 * Summary:	Dialogs definitions
 * Authors:	Boris Manojlovic <boris@steki.net>
 *
 * $Id: complex.ycp $
 */

{

textdomain "udba";

import "Label";
import "Popup";
import "Wizard";
//import "Wizard_hw";
import "Confirm";
import "Udba";
import "Pkg";
import "Package";
import "Popup";

include "udba/helps.ycp";

/**
 * Return a modification status
 * @return true if data was modified
 */
boolean Modified() {
    return Udba::Modified();
}

boolean ReallyAbort() {
    return !Udba::Modified() || Popup::ReallyAbort(true);
}

boolean PollAbort() {
    return UI::PollInput() == `abort;
}

/**
 * Read settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol ReadDialog() {
    Wizard::RestoreHelp(HELPS["read"]:"");
    Udba::SetAbortFunction(PollAbort);
    if (!Confirm::MustBeRoot()) return `abort;
    boolean ret = Udba::Read();
    return ret ? `next : `abort;
}


/**
 * Write settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol WriteDialog() {
    Wizard::RestoreHelp(HELPS["write"]:"");
    Udba::SetAbortFunction(PollAbort);
    boolean ret = Udba::Write();
    return ret ? `next : `abort;
}

/**
 * Function updates list of packages 
 * @param list <term> packageList 
 * @param term vals 
 * @return list<term>
 */

list<term> updatePkgList (list<term> packageList, term vals)
{
    string ver1 = "";
    string ver2 = "";
    list<term> copyOfpackageList = [];
    
    if ( size (packageList) == 0 ) {
        y2milestone("LIST EMPTY ADDING");
        copyOfpackageList = add (copyOfpackageList, vals);
        return copyOfpackageList;
    }
    copyOfpackageList = packageList;
    boolean exist = false;
    integer idx = 0;
    
    foreach(term t, packageList, {
        if (t[1]:nil == vals[1]:nil) {
            y2milestone("package in list removing...: %1", vals[1]:nil);
            ver1 = (string) t[2]:nil;
            ver2 = (string) vals[2]:nil;
            if ( ver1 < ver2 ) {
                vals[2] = mergestring([ ver1, ver2 ], " : ");
                vals[3] = "Update Available";
            } else if ( ver1 == ver2 ) {
                vals[3] = "No Update Available";
            }
            copyOfpackageList = remove(copyOfpackageList,idx);
            break;
        }
        idx = idx + 1;
    });
    copyOfpackageList = add (copyOfpackageList, vals);
    return copyOfpackageList;
}



/**
 * Create list of udba-* packages 
 * @return list <term>
 */

list <term> PreparePackagesList() {
    list<term> packageList = [];
    integer key = 1;
    string available = "";
    string pkg_version = "0.0";
    foreach (map<string,any> pkg, Pkg::ResolvableProperties("", `package, ""), {
        string pkg_name = pkg["name"]:"";
        if (regexpmatch(pkg_name, "^udba-" ) == true) {  
            if (pkg["status"]:nil == `available) {
                available="Not Installed";
            }
            packageList = updatePkgList (packageList,
                                        `item( 
                                            `id(key), 
                                            pkg["name"]:nil,
                                            pkg["version"]:"Null",
                                            available, 
                                            pkg["summary"]:nil
                                        ));
            key = key + 1;
        }
    });
    return packageList;
}
/*
 there is no popup from DoRemove package call so lets fake it
*/
boolean ShouldRemovePackage(string package_name) {
    return Popup::YesNoHeadline( "These packages will be removed:?", package_name);
}

/**
 * Helper functions for getting package name from table selection
 * @return string package name
*/
string GetPackageName() {
    integer row_id  = (integer) UI::QueryWidget(`id(`table), `CurrentItem);
    return (string) UI::QueryWidget(`table, `Cell( row_id, 0 ));
}

/**
 * Helper functions for getting package status from table selection
 * @return string status
*/
string GetUpdateStatus() {
    integer row_id  = (integer) UI::QueryWidget(`id(`table), `CurrentItem);
    return (string) UI::QueryWidget(`table, `Cell( row_id, 3 ));
}

//list <map<string,any>> selected_packages = [];
/**
 * Summary dialog
 * @return dialog result
 */
any SummaryDialog() {

    string caption = _("Universal Driver Build Assistant");
    
    list summary = Udba::Summary();
    
    list<term> packageList = PreparePackagesList();
    
    term contents = `VBox (
        `Left(`Label(_("Currently configured and build status of driver recipes"))),
        `Left(
            `VBox (
                `MinSize( 70, 3,
                    // A table header
                    `Table(`id(`table),
                           `opt(`notify),
                           `header("Package Name", "Version", "Upgrade Available","Description"), 
                            packageList)
            ),
            `HBox (
                    // [Install new recipe] [Build recipe] [Remove recipe]
                    // a push button
                    `PushButton(`id("InstallOrUpdate"), _("Install / Update recipe")),
                    // a push button
                    `PushButton(`id("BuildRecipe"), _("Build / Rebuild recipe")),
                    // a push button
                    `PushButton(`id("RemoveRecipe"), _("Remove recipe"))
                ),
            `VSpacing(`opt(`hstretch), 1)
           )
        ));

    Wizard::SetContentsButtons(caption, contents, HELPS["summary"]:"",
        Label::BackButton(), Label::FinishButton());

    any ret = nil;
    while(true) {

        ret = UI::UserInput();

        /* abort? */
        if(ret == `abort || ret == `cancel || ret == `back) {
            if(ReallyAbort()) break;
            else continue;
        }
        else if (ret == `table) {
            continue;
        }
        /* BuildRecipe dialog */
        else if(ret == "BuildRecipe") {
            y2milestone("BuildRecipe is called");
            Udba::current_working_package = GetPackageName();
            ret = `configure;
        }
        /* RemoveRecipe dialog */
        else if(ret == "RemoveRecipe") {
            y2milestone("RemoveRecipe is called");
            string package_name = GetPackageName();
            if (ShouldRemovePackage(package_name) == true ) {
                Package::DoRemove([ package_name ]);
                list <term> tmplist = PreparePackagesList();
                Popup::ClearFeedback();
                UI::ChangeWidget(`id(`table),`Items, tmplist);
            }
            continue;
        }
        /* RemoveRecipe dialog */
        else if(ret == "InstallOrUpdate") {
            y2milestone("InstallOrUpdate is called");
            any selected = UI::QueryWidget(`id(`table), `CurrentItem);
            if(selected == `other) {
                ret = `other;
            } else {
                string package_name = GetPackageName();
                y2milestone("Update for '%1' is '%2'", GetPackageName(), GetUpdateStatus());
                if (Package::InstalledAll([package_name]) == false) {
                    Package::InstallAll([package_name]);
                    Popup::ShowFeedback(_("Updating package information"),
                                        _("This may take a while"));
                    // this takes time...
                    list <term> tmplist = PreparePackagesList();
                    Popup::ClearFeedback();
                    UI::ChangeWidget(`id(`table),`Items, tmplist);
                    continue;
                } else {
                    continue;
                }
            }
            break;
        }
        else if(ret == `next) {
            break;
        }
        else {
            y2error("unexpected retcode: %1", ret);
            continue;
        }    
        y2milestone ("Returning ret=%1", ret);
        return ret;
    }

}

/* EOF */
}
